/*********************************************************************
*
*	file: wgpu_renderer_shaders.h
*	note: string literals auto-generated by gen_header_from_files.zig
*
**********************************************************************/
#ifndef __WGPU_RENDERER_SHADERS_H__
#define __WGPU_RENDERER_SHADERS_H__


//NOTE: string imported from src/graphics/wgsl_shaders/common.wgsl
const char* oc_wgsl_common = 
"struct oc_path\n"
"{\n"
"    uvTransform : mat3x3f,\n"
"    colors : array<vec4f, 4>,\n"
"    box: vec4f,\n"
"    clip: vec4f,\n"
"    cmd : u32,\n"
"    textureID : i32,\n"
"    hasGradient : i32,\n"
"    blendSpace : i32,\n"
"};\n"
"struct oc_path_elt\n"
"{\n"
"    pathIndex: i32,\n"
"    kind : i32,\n"
"    p : array<vec2f, 4>,\n"
"};\n"
"struct oc_segment\n"
"{\n"
"    kind : i32,\n"
"    pathIndex : i32,\n"
"    windingIncrement : i32,\n"
"    config : i32,\n"
"    box : vec4f,\n"
"    implicitMatrix : mat3x3f,\n"
"    hullVertex : vec2f,\n"
"    sign : f32,\n"
"    debugID : i32,\n"
"};\n"
"struct oc_tile_op\n"
"{\n"
"    kind : i32,\n"
"    next : i32,\n"
"    index : u32,\n"
"    windingOffsetOrCrossRight : i32,\n"
"};\n"
"struct oc_bin_queue\n"
"{\n"
"    windingOffset : i32,\n"
"    first : i32,\n"
"    last : i32,\n"
"};\n"
"struct oc_bin_queue_atomic\n"
"{\n"
"    windingOffset : atomic<i32>,\n"
"    first : atomic<i32>,\n"
"    last : i32,\n"
"};\n"
"struct oc_path_bin\n"
"{\n"
"    area : vec4i,\n"
"    binQueues : i32,\n"
"};\n"
"struct oc_chunk\n"
"{\n"
"    first : i32,\n"
"    last : i32,\n"
"};\n"
"struct oc_chunk_elt\n"
"{\n"
"    next : i32,\n"
"    pathIndex : u32,\n"
"};\n"
"struct oc_tile_queue\n"
"{\n"
"    tileCoord : vec2u,\n"
"    first : i32,\n"
"};\n"
"struct oc_debug_display_options\n"
"{\n"
"    showTileBorders : u32,\n"
"    showPathArea : u32,\n"
"    showClip : u32,\n"
"    textureOff: u32,\n"
"    debugTileQueues : u32,\n"
"};\n"
"const OC_CMD_FILL : u32 = 0;\n"
"const OC_CMD_STROKE : u32 = 1;\n"
"const OC_SEG_BL : i32 = 0; // curve on bottom left\n"
"const OC_SEG_BR : i32 = 1; // curve on bottom right\n"
"const OC_SEG_TL : i32 = 2; // curve on top left\n"
"const OC_SEG_TR : i32 = 3; // curve on top right\n"
"const OC_SEG_LINE : i32 = 1;\n"
"const OC_SEG_QUADRATIC : i32 = 2;\n"
"const OC_SEG_CUBIC : i32 = 3;\n"
"const OC_OP_START : i32 = 0;\n"
"const OC_OP_CLIP_FILL : i32 = 1;\n"
"const OC_OP_FILL : i32 = 2;\n"
"const OC_OP_SEGMENT : i32 = 3;\n"
"const OC_OP_END : i32 = 4;\n"
"fn squaref(x : f32) -> f32\n"
"{\n"
"    return(x*x);\n"
"}\n"
"fn cubef(x : f32) -> f32\n"
"{\n"
"    return(x*x*x);\n"
"}\n"
"fn ccw(a : vec2f, b : vec2f, c : vec2f) -> f32\n"
"{\n"
"    return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x));\n"
"}\n"
"fn side_of_segment(p : vec2f, seg : oc_segment) -> i32\n"
"{\n"
"    var side : i32 = 0;\n"
"    if(p.y > seg.box.w || p.y <= seg.box.y)\n"
"    {\n"
"        if(p.x > seg.box.x && p.x <= seg.box.z)\n"
"        {\n"
"            if(p.y > seg.box.w)\n"
"            {\n"
"                if(seg.config == OC_SEG_TL || seg.config == OC_SEG_BR)\n"
"                {\n"
"                    side = -1;\n"
"                }\n"
"                else\n"
"                {\n"
"                    side = 1;\n"
"                }\n"
"            }\n"
"            else\n"
"            {\n"
"                if(seg.config == OC_SEG_TL || seg.config == OC_SEG_BR)\n"
"                {\n"
"                    side = 1;\n"
"                }\n"
"                else\n"
"                {\n"
"                    side = -1;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    else if(p.x > seg.box.z)\n"
"    {\n"
"        side = 1;\n"
"    }\n"
"    else if(p.x <= seg.box.x)\n"
"    {\n"
"        side = -1;\n"
"    }\n"
"    else\n"
"    {\n"
"        var a : vec2f;\n"
"        var b : vec2f;\n"
"        var c : vec2f;\n"
"        switch(seg.config)\n"
"        {\n"
"            case OC_SEG_TL:\n"
"            {\n"
"                a = seg.box.xy;\n"
"                b = seg.box.zw;\n"
"            }\n"
"            case OC_SEG_BR:\n"
"            {\n"
"                a = seg.box.zw;\n"
"                b = seg.box.xy;\n"
"            }\n"
"            case OC_SEG_TR:\n"
"            {\n"
"                a = seg.box.xw;\n"
"                b = seg.box.zy;\n"
"            }\n"
"            case OC_SEG_BL, default:\n"
"            {\n"
"                a = seg.box.zy;\n"
"                b = seg.box.xw;\n"
"            }\n"
"        }\n"
"        c = seg.hullVertex;\n"
"        if(ccw(a, b, p) < 0)\n"
"        {\n"
"            // other side of the diagonal\n"
"            if(seg.config == OC_SEG_BR || seg.config == OC_SEG_TR)\n"
"            {\n"
"                side = -1;\n"
"            }\n"
"            else\n"
"            {\n"
"                side = 1;\n"
"            }\n"
"        }\n"
"        else if(ccw(b, c, p) < 0 || ccw(c, a, p) < 0)\n"
"        {\n"
"            // same side of the diagonal, but outside curve hull\n"
"            if(seg.config == OC_SEG_BL || seg.config == OC_SEG_TL)\n"
"            {\n"
"                side = -1;\n"
"            }\n"
"            else\n"
"            {\n"
"                side = 1;\n"
"            }\n"
"        }\n"
"        else\n"
"        {\n"
"            switch(seg.kind)\n"
"            {\n"
"                case OC_SEG_LINE, default:\n"
"                {\n"
"                    side = 1;\n"
"                }\n"
"                case OC_SEG_QUADRATIC:\n"
"                {\n"
"                    let ph : vec3f = vec3f(p.x, p.y, 1);\n"
"                    let klm : vec3f = seg.implicitMatrix * ph;\n"
"                    let test : f32 = (klm.x * klm.x - klm.y) * klm.z;\n"
"                    if(test < 0)\n"
"                    {\n"
"                        side = -1;\n"
"                    }\n"
"                    else\n"
"                    {\n"
"                        side = 1;\n"
"                    }\n"
"                }\n"
"                case OC_SEG_CUBIC:\n"
"                {\n"
"                    let ph : vec3f = vec3f(p.x, p.y, 1);\n"
"                    let klm : vec3f = seg.implicitMatrix * ph;\n"
"                    let test : f32 = seg.sign * (klm.x * klm.x * klm.x - klm.y * klm.z);\n"
"                    if(test < 0)\n"
"                    {\n"
"                        side = -1;\n"
"                    }\n"
"                    else\n"
"                    {\n"
"                        side = 1;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    return (side);\n"
"}\n";

//NOTE: string imported from src/graphics/wgsl_shaders/path_setup.wgsl
const char* oc_wgsl_path_setup = 
"//------------------------------------------------------------------------------------------------\n"
"// Path setup\n"
"//------------------------------------------------------------------------------------------------\n"
"@group(0) @binding(0) var<storage, read> pathBuffer : array<oc_path>;\n"
"@group(0) @binding(1) var<uniform> pathCount : u32;\n"
"@group(0) @binding(2) var<storage, read_write> pathBins : array<oc_path_bin>;\n"
"@group(0) @binding(3) var<storage, read_write> binQueueBuffer : array<oc_bin_queue>;\n"
"@group(0) @binding(4) var<storage, read_write> binQueueCount : atomic<u32>;\n"
"@group(0) @binding(5) var<uniform> tileSize : i32;\n"
"@compute @workgroup_size(16, 16) fn path_setup(@builtin(num_workgroups) workGroupCount : vec3u,\n"
"                                               @builtin(workgroup_id) workGroupID : vec3u,\n"
"                                               @builtin(local_invocation_id) localID : vec3u)\n"
"{\n"
"    let invocationsPerWorkGroups : u32 = 16*16;\n"
"    let workGroupIndex : u32 = workGroupID.y*workGroupCount.x + workGroupID.x;\n"
"    let pathIndex : u32 = workGroupIndex * invocationsPerWorkGroups + localID.y*16 + localID.x;\n"
"    if(pathIndex >= pathCount)\n"
"    {\n"
"        return;\n"
"    }\n"
"    let path = pathBuffer[pathIndex];\n"
"    //NOTE: we don't clip on the right, since we need those tiles to accurately compute\n"
"    //      the prefix sum of winding increments in the backprop pass.\n"
"    let clippedBox = vec4f(max(path.box.x, path.clip.x),\n"
"                           max(path.box.y, path.clip.y),\n"
"                           path.box.z,\n"
"                           min(path.box.w, path.clip.w));\n"
"    let firstTile = vec2i(clippedBox.xy) / tileSize;\n"
"    let lastTile = vec2i(clippedBox.zw) / tileSize;\n"
"    let nTilesX : i32 = max(0, lastTile.x - firstTile.x + 1);\n"
"    let nTilesY : i32 = max(0, lastTile.y - firstTile.y + 1);\n"
"    let tileCount : u32 = u32(nTilesX * nTilesY);\n"
"    let binQueuesIndex : u32 = atomicAdd(&binQueueCount, tileCount);\n"
"    if(binQueuesIndex + tileCount >= arrayLength(&binQueueBuffer))\n"
"    {\n"
"        pathBins[pathIndex].area = vec4i(0, 0, 0, 0);\n"
"        pathBins[pathIndex].binQueues = -1;\n"
"    }\n"
"    else\n"
"    {\n"
"        pathBins[pathIndex].area = vec4i(firstTile.x, firstTile.y, nTilesX, nTilesY);\n"
"        pathBins[pathIndex].binQueues = i32(binQueuesIndex);\n"
"        for(var i : u32 = 0; i < tileCount; i++)\n"
"        {\n"
"            binQueueBuffer[binQueuesIndex + i].first = -1;\n"
"            binQueueBuffer[binQueuesIndex + i].last = -1;\n"
"            binQueueBuffer[binQueuesIndex + i].windingOffset = 0;\n"
"        }\n"
"    }\n"
"}\n";

//NOTE: string imported from src/graphics/wgsl_shaders/segment_setup.wgsl
const char* oc_wgsl_segment_setup = 
"//------------------------------------------------------------------------------------------------\n"
"// Segment setup\n"
"//------------------------------------------------------------------------------------------------\n"
"@group(0) @binding(0) var<storage, read> pathBuffer : array<oc_path>;\n"
"@group(0) @binding(1) var<storage, read> eltBuffer : array<oc_path_elt>;\n"
"@group(0) @binding(2) var<uniform> eltCount : u32;\n"
"@group(0) @binding(3) var<storage, read_write> segmentBuffer : array<oc_segment>;\n"
"@group(0) @binding(4) var<storage, read_write> segmentCount : atomic<u32>;\n"
"@group(0) @binding(5) var<storage, read_write> pathBins : array<oc_path_bin>;\n"
"@group(0) @binding(6) var<storage, read_write> binQueues : array<oc_bin_queue_atomic>;\n"
"@group(0) @binding(7) var<storage, read_write> tileOpBuffer : array<oc_tile_op>;\n"
"@group(0) @binding(8) var<storage, read_write> tileOpCount : atomic<u32>;\n"
"@group(0) @binding(9) var<uniform> tileSize : u32;\n"
"fn push_segment(p: array<vec2f, 4>, kind : i32, pathIndex : i32) -> u32\n"
"{\n"
"    let segIndex = atomicAdd(&segmentCount, 1u);\n"
"    if(segIndex < arrayLength(&segmentBuffer))\n"
"    {\n"
"        var s : vec2f;\n"
"        var e : vec2f;\n"
"        var c : vec2f;\n"
"        switch(kind)\n"
"        {\n"
"            case OC_SEG_LINE, default:\n"
"            {\n"
"                s = p[0];\n"
"                c = p[0];\n"
"                e = p[1];\n"
"            }\n"
"            case OC_SEG_QUADRATIC:\n"
"            {\n"
"                s = p[0];\n"
"                c = p[1];\n"
"                e = p[2];\n"
"            }\n"
"            case OC_SEG_CUBIC:\n"
"            {\n"
"                s = p[0];\n"
"                let sqrNorm0 : f32 = dot(p[1] - p[0], p[1] - p[0]);\n"
"                let sqrNorm1 : f32 = dot(p[3] - p[2], p[3] - p[2]);\n"
"                if(sqrNorm0 < sqrNorm1)\n"
"                {\n"
"                    c = p[2];\n"
"                }\n"
"                else\n"
"                {\n"
"                    c = p[1];\n"
"                }\n"
"                e = p[3];\n"
"            }\n"
"        }\n"
"        let seg = &segmentBuffer[segIndex];\n"
"        let goingUp : bool = e.y >= s.y;\n"
"        let goingRight : bool = e.x >= s.x;\n"
"        (*seg).kind = kind;\n"
"        (*seg).pathIndex = pathIndex;\n"
"        if(goingUp)\n"
"        {\n"
"            (*seg).windingIncrement = 1;\n"
"        }\n"
"        else\n"
"        {\n"
"            (*seg).windingIncrement = -1;\n"
"        }\n"
"        (*seg).box = vec4f(\n"
"            min(s.x, e.x),\n"
"            min(s.y, e.y),\n"
"            max(s.x, e.x),\n"
"            max(s.y, e.y)\n"
"        );\n"
"        let dx = c.x - (*seg).box.x;\n"
"        let dy = c.y - (*seg).box.y;\n"
"        let alpha = ((*seg).box.w - (*seg).box.y) / ((*seg).box.z - (*seg).box.x);\n"
"        let ofs = (*seg).box.w - (*seg).box.y;\n"
"        if(goingUp == goingRight)\n"
"        {\n"
"            if(kind == OC_SEG_LINE)\n"
"            {\n"
"                (*seg).config = OC_SEG_BR;\n"
"            }\n"
"            else if(dy > alpha * dx)\n"
"            {\n"
"                (*seg).config = OC_SEG_TL;\n"
"            }\n"
"            else\n"
"            {\n"
"                (*seg).config = OC_SEG_BR;\n"
"            }\n"
"        }\n"
"        else\n"
"        {\n"
"            if(kind == OC_SEG_LINE)\n"
"            {\n"
"                (*seg).config = OC_SEG_TR;\n"
"            }\n"
"            else if(dy < ofs - alpha * dx)\n"
"            {\n"
"                (*seg).config = OC_SEG_BL;\n"
"            }\n"
"            else\n"
"            {\n"
"                (*seg).config = OC_SEG_TR;\n"
"            }\n"
"        }\n"
"    }\n"
"    return(segIndex);\n"
"}\n"
"fn bin_to_tiles(segIndex : u32)\n"
"{\n"
"    //NOTE: add segment index to the queues of tiles it overlaps with\n"
"    let seg : oc_segment = segmentBuffer[segIndex];\n"
"    let pathBin : oc_path_bin = pathBins[seg.pathIndex];\n"
"    let pathArea : vec4i  = pathBin.area;\n"
"    let coveredTiles : vec4i = vec4i(seg.box) / i32(tileSize);\n"
"    let xMin : i32 = max(0, coveredTiles.x - pathArea.x);\n"
"    let yMin : i32 = max(0, coveredTiles.y - pathArea.y);\n"
"    let xMax : i32 = min(coveredTiles.z - pathArea.x, pathArea.z - 1);\n"
"    let yMax : i32 = min(coveredTiles.w - pathArea.y, pathArea.w - 1);\n"
"    for(var y : i32 = yMin; y <= yMax; y++)\n"
"    {\n"
"        for(var x : i32 = xMin; x <= xMax; x++)\n"
"        {\n"
"            let tileBox = vec4f(f32(x + pathArea.x),\n"
"                                f32(y + pathArea.y),\n"
"                                f32(x + pathArea.x + 1),\n"
"                                f32(y + pathArea.y + 1))\n"
"                         * f32(tileSize);\n"
"            let bl = vec2f(tileBox.x, tileBox.y);\n"
"            let br = vec2f(tileBox.z, tileBox.y);\n"
"            let tr = vec2f(tileBox.z, tileBox.w);\n"
"            let tl = vec2f(tileBox.x, tileBox.w);\n"
"            let sbl : i32 = side_of_segment(bl, seg);\n"
"            let sbr : i32 = side_of_segment(br, seg);\n"
"            let str : i32 = side_of_segment(tr, seg);\n"
"            let stl : i32 = side_of_segment(tl, seg);\n"
"            let crossL : bool = (stl * sbl < 0);\n"
"            let crossR : bool = (str * sbr < 0);\n"
"            let crossT : bool = (stl * str < 0);\n"
"            let crossB : bool = (sbl * sbr < 0);\n"
"            var s0 : vec2f;\n"
"            var s1 : vec2f;\n"
"            if(seg.config == OC_SEG_TL || seg.config == OC_SEG_BR)\n"
"            {\n"
"                s0 = seg.box.xy;\n"
"                s1 = seg.box.zw;\n"
"            }\n"
"            else\n"
"            {\n"
"                s0 = seg.box.xw;\n"
"                s1 = seg.box.zy;\n"
"            }\n"
"            var s0Inside : bool = s0.x >= tileBox.x\n"
"                               && s0.x < tileBox.z\n"
"                               && s0.y >= tileBox.y\n"
"                               && s0.y < tileBox.w;\n"
"            var s1Inside : bool = s1.x >= tileBox.x\n"
"                               && s1.x < tileBox.z\n"
"                               && s1.y >= tileBox.y\n"
"                               && s1.y < tileBox.w;\n"
"            if(crossL || crossR || crossT || crossB || s0Inside || s1Inside)\n"
"            {\n"
"                let tileOpIndex : u32 = atomicAdd(&tileOpCount, 1u);\n"
"                if(tileOpIndex < arrayLength(&tileOpBuffer))\n"
"                {\n"
"                    tileOpBuffer[tileOpIndex].kind = OC_OP_SEGMENT;\n"
"                    tileOpBuffer[tileOpIndex].index = segIndex;\n"
"                    tileOpBuffer[tileOpIndex].windingOffsetOrCrossRight = 0;\n"
"                    tileOpBuffer[tileOpIndex].next = -1;\n"
"                    let binQueueIndex = i32(pathBin.binQueues) + y * pathArea.z + x;\n"
"                    tileOpBuffer[tileOpIndex].next = atomicExchange(&binQueues[binQueueIndex].first, i32(tileOpIndex));\n"
"                    if(tileOpBuffer[tileOpIndex].next == -1)\n"
"                    {\n"
"                        binQueues[binQueueIndex].last = i32(tileOpIndex);\n"
"                    }\n"
"                    //NOTE: if the segment crosses the tile's bottom boundary, update the tile's winding offset\n"
"                    if(crossB)\n"
"                    {\n"
"                        atomicAdd(&binQueues[binQueueIndex].windingOffset, seg.windingIncrement);\n"
"                    }\n"
"                    //NOTE: if the segment crosses the right boundary, mark it.\n"
"                    if(crossR)\n"
"                    {\n"
"                        tileOpBuffer[tileOpIndex].windingOffsetOrCrossRight = 1;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"//--------------------------------------------------------------\n"
"//NOTE: Lines\n"
"//--------------------------------------------------------------\n"
"fn line_setup(p : array<vec2f, 4>, pathIndex : i32)\n"
"{\n"
"    var segIndex = push_segment(p, OC_SEG_LINE, pathIndex);\n"
"    if(segIndex < arrayLength(&segmentBuffer))\n"
"    {\n"
"        segmentBuffer[segIndex].hullVertex = p[0];\n"
"        segmentBuffer[segIndex].debugID = 0;\n"
"        bin_to_tiles(segIndex);\n"
"    }\n"
"}\n"
"//--------------------------------------------------------------\n"
"//NOTE: Quadratics\n"
"//--------------------------------------------------------------\n"
"fn quadratic_blossom(p : array<vec2f, 4>, u : f32, v : f32) -> vec2f\n"
"{\n"
"    let b10 : vec2f = u * p[1] + (1 - u) * p[0];\n"
"    let b11 : vec2f = u * p[2] + (1 - u) * p[1];\n"
"    let b20 : vec2f = v * b11 + (1 - v) * b10;\n"
"    return (b20);\n"
"}\n"
"fn quadratic_slice(p : array<vec2f, 4>, s0 : f32, s1 : f32, sp : ptr<function, array<vec2f ,4>>)\n"
"{\n"
"    /*NOTE: using blossoms to compute sub-curve control points ensure that the fourth point\n"
"	        of sub-curve (s0, s1) and the first point of sub-curve (s1, s3) match.\n"
"	        However, due to numerical errors, the evaluation of B(s=0) might not be equal to\n"
"	        p[0] (and likewise, B(s=1) might not equal p[3]).\n"
"	        We handle that case explicitly to ensure that we don't create gaps in the paths.\n"
"	*/\n"
"	if(s0 == 0)\n"
"	{\n"
"        (*sp)[0] =  p[0];\n"
"    }\n"
"    else\n"
"    {\n"
"        (*sp)[0] = quadratic_blossom(p, s0, s0);\n"
"    }\n"
"    (*sp)[1] = quadratic_blossom(p, s0, s1);\n"
"    if(s1 == 1)\n"
"    {\n"
"        (*sp)[2] = p[2];\n"
"    }\n"
"    else\n"
"    {\n"
"        (*sp)[2] = quadratic_blossom(p, s1, s1);\n"
"    }\n"
"}\n"
"fn quadratic_monotonize(p : array<vec2f, 4>, splits : ptr<function, array<f32,4>>) -> i32\n"
"{\n"
"    //NOTE: compute split points\n"
"    var count : i32 = 0;\n"
"    (*splits)[0] = 0;\n"
"    count++;\n"
"    var r : vec2f = (p[0] - p[1]) / (p[2] - 2 * p[1] + p[0]);\n"
"    if(r.x > r.y)\n"
"    {\n"
"        let tmp : f32 = r.x;\n"
"        r.x = r.y;\n"
"        r.y = tmp;\n"
"    }\n"
"    if(r.x > 0 && r.x < 1)\n"
"    {\n"
"        (*splits)[count] = r.x;\n"
"        count++;\n"
"    }\n"
"    if(r.y > 0 && r.y < 1)\n"
"    {\n"
"        (*splits)[count] = r.y;\n"
"        count++;\n"
"    }\n"
"    (*splits)[count] = 1;\n"
"    count++;\n"
"    return (count);\n"
"}\n"
"fn quadratic_emit(p : array<vec2f, 4>, pathIndex : i32, debugID : i32)\n"
"{\n"
"    var segIndex : u32 = push_segment(p, OC_SEG_QUADRATIC, pathIndex);\n"
"    if(segIndex < arrayLength(&segmentBuffer))\n"
"    {\n"
"        let seg = &segmentBuffer[segIndex];\n"
"        //NOTE: compute implicit equation matrix\n"
"        let det : f32 = p[0].x * (p[1].y - p[2].y) + p[1].x * (p[2].y - p[0].y) + p[2].x * (p[0].y - p[1].y);\n"
"        let a : f32 = p[0].y - p[1].y + 0.5 * (p[2].y - p[0].y);\n"
"        let b : f32 = p[1].x - p[0].x + 0.5 * (p[0].x - p[2].x);\n"
"        let c : f32 = p[0].x * p[1].y - p[1].x * p[0].y + 0.5 * (p[2].x * p[0].y - p[0].x * p[2].y);\n"
"        let d : f32 = p[0].y - p[1].y;\n"
"        let e : f32 = p[1].x - p[0].x;\n"
"        let f : f32 = p[0].x * p[1].y - p[1].x * p[0].y;\n"
"        var flip : f32;\n"
"        if(  (*seg).config == OC_SEG_TL\n"
"          || (*seg).config == OC_SEG_BL)\n"
"        {\n"
"            flip = -1;\n"
"        }\n"
"        else\n"
"        {\n"
"            flip = 1;\n"
"        }\n"
"        let g : f32 = flip * (p[2].x * (p[0].y - p[1].y) + p[0].x * (p[1].y - p[2].y) + p[1].x * (p[2].y - p[0].y));\n"
"        (*seg).implicitMatrix = (1 / det) * mat3x3f(a, d, 0., b, e, 0., c, f, g);\n"
"        (*seg).hullVertex = p[1];\n"
"        (*seg).debugID = debugID;\n"
"        bin_to_tiles(segIndex);\n"
"    }\n"
"}\n"
"fn quadratic_setup(p : array<vec2f, 4>, pathIndex : i32)\n"
"{\n"
"    var splits : array<f32, 4>;\n"
"    var splitCount : i32 = quadratic_monotonize(p, &splits);\n"
"    //NOTE: produce b√©zier curve for each consecutive pair of roots\n"
"    for(var sliceIndex : i32 = 0; sliceIndex < splitCount - 1; sliceIndex++)\n"
"    {\n"
"        var sp : array<vec2f, 4>;\n"
"        quadratic_slice(p, splits[sliceIndex], splits[sliceIndex + 1], &sp);\n"
"        quadratic_emit(sp, pathIndex, sliceIndex);\n"
"    }\n"
"}\n"
"//--------------------------------------------------------------\n"
"//NOTE: Cubics\n"
"//--------------------------------------------------------------\n"
"fn quadratic_roots_with_det(a : f32, b : f32, c : f32, det : f32, r : ptr<function, array<f32, 2>>) -> i32\n"
"{\n"
"    var count : i32 = 0;\n"
"    if(a == 0)\n"
"    {\n"
"        if(b != 0)\n"
"        {\n"
"            count = 1;\n"
"            (*r)[0] = -c / b;\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"        let B : f32 = b/2.0;\n"
"        if(det >= 0)\n"
"        {\n"
"            if(det == 0)\n"
"            {\n"
"                count = 1;\n"
"            }\n"
"            else\n"
"            {\n"
"                count = 2;\n"
"            }\n"
"            if(B > 0)\n"
"            {\n"
"                let q : f32 = B + sqrt(det);\n"
"                (*r)[0] = -c / q;\n"
"                (*r)[1] = -q / a;\n"
"            }\n"
"            else if(B < 0)\n"
"            {\n"
"                let q : f32 = -B + sqrt(det);\n"
"                (*r)[0] = q / a;\n"
"                (*r)[1] = c / q;\n"
"            }\n"
"            else\n"
"            {\n"
"                let q : f32 = sqrt(-a * c);\n"
"                if(abs(a) >= abs(c))\n"
"                {\n"
"                    (*r)[0] = q / a;\n"
"                    (*r)[1] = -q / a;\n"
"                }\n"
"                else\n"
"                {\n"
"                    (*r)[0] = -c / q;\n"
"                    (*r)[1] = c / q;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    if(count > 1 && (*r)[0] > (*r)[1])\n"
"    {\n"
"        let tmp : f32 = (*r)[0];\n"
"        (*r)[0] = (*r)[1];\n"
"        (*r)[1] = tmp;\n"
"    }\n"
"    return (count);\n"
"}\n"
"fn quadratic_roots(a : f32, b : f32, c : f32, r : ptr<function, array<f32, 2>>) -> i32\n"
"{\n"
"    let det : f32 = squaref(b) / 4. - a * c;\n"
"    return (quadratic_roots_with_det(a, b, c, det, r));\n"
"}\n"
"const CUBIC_ERROR : i32 = 0;\n"
"const CUBIC_SERPENTINE : i32 = 1;\n"
"const CUBIC_CUSP : i32 = 2;\n"
"const CUBIC_CUSP_INFINITY : i32 = 3;\n"
"const CUBIC_LOOP : i32 = 4;\n"
"const CUBIC_DEGENERATE_QUADRATIC : i32 = 5;\n"
"const CUBIC_DEGENERATE_LINE : i32 = 6;\n"
"struct cubic_info\n"
"{\n"
"    kind : i32,\n"
"    K : mat4x4f,\n"
"    ts : array<vec2f, 2>,\n"
"    d1 : f32,\n"
"    d2 : f32,\n"
"    d3 : f32,\n"
"};\n"
"fn cubic_classify(c : array<vec2f, 4>) -> cubic_info\n"
"{\n"
"    var F : mat4x4f;\n"
"    var result : cubic_info;\n"
"    result.kind = CUBIC_ERROR;\n"
"    /*NOTE(martin):\n"
"		now, compute determinants d0, d1, d2, d3, which gives the coefficients of the\n"
"	        inflection points polynomial:\n"
"		I(t, s) = d0*t^3 - 3*d1*t^2*s + 3*d2*t*s^2 - d3*s^3\n"
"		The roots of this polynomial are the inflection points of the parametric curve, in homogeneous\n"
"		coordinates (ie we can have an inflection point at inifinity with s=0).\n"
"		         |x3 y3 w3|              |x3 y3 w3|             |x3 y3 w3|              |x2 y2 w2|\n"
"		d0 = det |x2 y2 w2|    d1 = -det |x2 y2 w2|    d2 = det |x1 y1 w1|    d3 = -det |x1 y1 w1|\n"
"		         |x1 y1 w1|              |x0 y0 w0|             |x0 y0 w0|              |x0 y0 w0|\n"
"		In our case, the pi.w equal 1 (no point at infinity), so _in_the_power_basis_, w1 = w2 = w3 = 0 and w0 = 1\n"
"		(which also means d0 = 0)\n"
"		//WARN: there seems to be a mismatch between the signs of the d_i and the orientation test in the Loop-Blinn paper?\n"
"		//      flipping the sign of the d_i doesn't change the roots (and the implicit matrix), but it does change the orientation.\n"
"		//      Keeping the signs of the paper puts the interior on the left of parametric travel, unlike what's stated in the paper.\n"
"		//      this may very well be an error on my part that's cancelled by flipping the signs of the d_i though!\n"
"	*/\n"
"    let d1 : f32 = -(c[3].y * c[2].x - c[3].x * c[2].y);\n"
"    let d2 : f32 = -(c[3].x * c[1].y - c[3].y * c[1].x);\n"
"    let d3 : f32 = -(c[2].y * c[1].x - c[2].x * c[1].y);\n"
"    result.d1 = d1;\n"
"    result.d2 = d2;\n"
"    result.d3 = d3;\n"
"    //NOTE(martin): compute the second factor of the discriminant discr(I) = d1^2*(3*d2^2 - 4*d3*d1)\n"
"    let discrFactor2 : f32 = 3.0 * squaref(d2) - 4.0 * d3 * d1;\n"
"    //NOTE(martin): each following case gives the number of roots, hence the category of the parametric curve\n"
"    if(abs(d1) <= 1e-6 && abs(d2) <= 1e-6 && abs(d3) > 1e-6)\n"
"    {\n"
"        //NOTE(martin): quadratic degenerate case\n"
"        //NOTE(martin): compute quadratic curve control point, which is at p0 + 1.5*(p1-p0) = 1.5*p1 - 0.5*p0\n"
"        result.kind = CUBIC_DEGENERATE_QUADRATIC;\n"
"    }\n"
"    else if((discrFactor2 > 0 && abs(d1) > 1e-6)\n"
"            || (discrFactor2 == 0 && abs(d1) > 1e-6))\n"
"    {\n"
"        //NOTE(martin): serpentine curve or cusp with inflection at infinity\n"
"        //              (these two cases are handled the same way).\n"
"        //NOTE(martin): compute the solutions (tl, sl), (tm, sm), and (tn, sn) of the inflection point equation\n"
"        var tmtl : array<f32, 2>;\n"
"        quadratic_roots_with_det(1, -2 * d2, (4. / 3. * d1 * d3), (1. / 3.) * discrFactor2, &tmtl);\n"
"        var tm : f32 = tmtl[0];\n"
"        var sm : f32 = 2 * d1;\n"
"        var tl : f32 = tmtl[1];\n"
"        var sl : f32 = 2 * d1;\n"
"        var invNorm : f32 = 1 / sqrt(squaref(tm) + squaref(sm));\n"
"        tm *= invNorm;\n"
"        sm *= invNorm;\n"
"        invNorm = 1 / sqrt(squaref(tl) + squaref(sl));\n"
"        tl *= invNorm;\n"
"        sl *= invNorm;\n"
"        /*NOTE(martin):\n"
"			the power basis coefficients of points k,l,m,n are collected into the rows of the 4x4 matrix F:\n"
"				| tl*tm            tl^3        tm^3        1 |\n"
"				| -sm*tl - sl*tm   -3sl*tl^2   -3*sm*tm^2  0 |\n"
"				| sl*sm            3*sl^2*tl   3*sm^2*tm   0 |\n"
"				| 0                -sl^3       -sm^3       0 |\n"
"		*/\n"
"		if(discrFactor2 > 0 && d1 != 0)\n"
"		{\n"
"            result.kind = CUBIC_SERPENTINE;\n"
"        }\n"
"        else\n"
"        {\n"
"            result.kind = CUBIC_CUSP;\n"
"        }\n"
"        F = mat4x4f(tl * tm, -sm * tl - sl * tm, sl * sm, 0,\n"
"                    cubef(tl), -3 * sl * squaref(tl), 3 * squaref(sl) * tl, -cubef(sl),\n"
"                    cubef(tm), -3 * sm * squaref(tm), 3 * squaref(sm) * tm, -cubef(sm),\n"
"                    1, 0, 0, 0);\n"
"        result.ts[0] = vec2f(tm, sm);\n"
"        result.ts[1] = vec2f(tl, sl);\n"
"    }\n"
"    else if(discrFactor2 < 0 && abs(d1) > 1e-6)\n"
"    {\n"
"        //NOTE(martin): loop curve\n"
"        result.kind = CUBIC_LOOP;\n"
"        var tetd : array<f32, 2>;\n"
"        quadratic_roots_with_det(1, -2 * d2, 4 * (squaref(d2) - d1 * d3), -discrFactor2, &tetd);\n"
"        var td : f32 = tetd[1];\n"
"        var sd : f32 = 2 * d1;\n"
"        var te : f32 = tetd[0];\n"
"        var se : f32 = 2 * d1;\n"
"        var invNorm : f32 = 1 / sqrt(squaref(td) + squaref(sd));\n"
"        td *= invNorm;\n"
"        sd *= invNorm;\n"
"        invNorm = 1 / sqrt(squaref(te) + squaref(se));\n"
"        te *= invNorm;\n"
"        se *= invNorm;\n"
"        /*NOTE(martin):\n"
"			the power basis coefficients of points k,l,m,n are collected into the rows of the 4x4 matrix F:\n"
"				| td*te            td^2*te                 td*te^2                1 |\n"
"				| -se*td - sd*te   -se*td^2 - 2sd*te*td    -sd*te^2 - 2*se*td*te  0 |\n"
"				| sd*se            te*sd^2 + 2*se*td*sd    td*se^2 + 2*sd*te*se   0 |\n"
"				| 0                -sd^2*se                -sd*se^2               0 |\n"
"		*/\n"
"        F = mat4x4f(td * te, -se * td - sd * te, sd * se, 0,\n"
"                    squaref(td) * te, -se * squaref(td) - 2 * sd * te * td, te * squaref(sd) + 2 * se * td * sd, -squaref(sd) * se,\n"
"                    td * squaref(te), -sd * squaref(te) - 2 * se * td * te, td * squaref(se) + 2 * sd * te * se, -sd * squaref(se),\n"
"                    1, 0, 0, 0);\n"
"        result.ts[0] = vec2f(td, sd);\n"
"        result.ts[1] = vec2f(te, se);\n"
"    }\n"
"    else if(d2 != 0)\n"
"    {\n"
"        //NOTE(martin): cusp with cusp at infinity\n"
"        var tl : f32 = d3;\n"
"        var sl : f32 = 3 * d2;\n"
"        let invNorm : f32 = 1 / sqrt(squaref(tl) + squaref(sl));\n"
"        tl *= invNorm;\n"
"        sl *= invNorm;\n"
"        /*NOTE(martin):\n"
"			the power basis coefficients of points k,l,m,n are collected into the rows of the 4x4 matrix F:\n"
"				| tl    tl^3        1  1 |\n"
"				| -sl   -3sl*tl^2   0  0 |\n"
"				| 0     3*sl^2*tl   0  0 |\n"
"				| 0     -sl^3       0  0 |\n"
"		*/\n"
"        result.kind = CUBIC_CUSP_INFINITY;\n"
"        F = mat4x4f(tl, -sl, 0, 0,\n"
"                    cubef(tl), -3 * sl * squaref(tl), 3 * squaref(sl) * tl, -cubef(sl),\n"
"                    1, 0, 0, 0,\n"
"                    1, 0, 0, 0);\n"
"        result.ts[0] = vec2f(tl, sl);\n"
"        result.ts[1] = vec2f(0, 0);\n"
"    }\n"
"    else\n"
"    {\n"
"        //NOTE(martin): line or point degenerate case\n"
"        result.kind = CUBIC_DEGENERATE_LINE;\n"
"    }\n"
"    /*\n"
"			F is then multiplied by M3^(-1) on the left which yelds the bezier coefficients k, l, m, n\n"
"			at the control points.\n"
"			               | 1  0   0   0 |\n"
"				M3^(-1) =  | 1  1/3 0   0 |\n"
"				           | 1  2/3 1/3 0 |\n"
"					       | 1  1   1   1 |\n"
"	*/\n"
"    let invM3 = mat4x4f(1, 1, 1, 1,\n"
"                        0, 1. / 3., 2. / 3., 1,\n"
"                        0, 0, 1. / 3., 1,\n"
"                        0, 0, 0, 1);\n"
"    result.K = transpose(invM3 * F);\n"
"    return (result);\n"
"}\n"
"fn cubic_blossom(p : array<vec2f, 4>, u : f32, v : f32, w : f32) -> vec2f\n"
"{\n"
"    let b10 : vec2f = u * p[1] + (1 - u) * p[0];\n"
"    let b11 : vec2f = u * p[2] + (1 - u) * p[1];\n"
"    let b12 : vec2f = u * p[3] + (1 - u) * p[2];\n"
"    let b20 : vec2f = v * b11 + (1 - v) * b10;\n"
"    let b21 : vec2f = v * b12 + (1 - v) * b11;\n"
"    let b30 : vec2f = w * b21 + (1 - w) * b20;\n"
"    return (b30);\n"
"}\n"
"fn cubic_slice(p : array<vec2f, 4>, s0 : f32, s1 : f32, sp : ptr<function, array<vec2f, 4>>)\n"
"{\n"
"    /*NOTE: using blossoms to compute sub-curve control points ensure that the fourth point\n"
"	        of sub-curve (s0, s1) and the first point of sub-curve (s1, s3) match.\n"
"	        However, due to numerical errors, the evaluation of B(s=0) might not be equal to\n"
"	        p[0] (and likewise, B(s=1) might not equal p[3]).\n"
"	        We handle that case explicitly to ensure that we don't create gaps in the paths.\n"
"	*/\n"
"	if(s0 == 0)\n"
"	{\n"
"        (*sp)[0] =  p[0];\n"
"    }\n"
"    else\n"
"    {\n"
"        (*sp)[0] = cubic_blossom(p, s0, s0, s0);\n"
"    }\n"
"    (*sp)[1] = cubic_blossom(p, s0, s0, s1);\n"
"    (*sp)[2] = cubic_blossom(p, s0, s1, s1);\n"
"    if(s1 == 1)\n"
"    {\n"
"        (*sp)[3] = p[3];\n"
"    }\n"
"    else\n"
"    {\n"
"        (*sp)[3] = cubic_blossom(p, s1, s1, s1);\n"
"    }\n"
"}\n"
"fn barycentric_matrix(v0 : vec2f, v1 : vec2f, v2 : vec2f) -> mat3x3f\n"
"{\n"
"    let det : f32 = v0.x * (v1.y - v2.y) + v1.x * (v2.y - v0.y) + v2.x * (v0.y - v1.y);\n"
"    var B = mat3x3f(v1.y - v2.y, v2.y - v0.y, v0.y - v1.y,\n"
"                    v2.x - v1.x, v0.x - v2.x, v1.x - v0.x,\n"
"                    v1.x * v2.y - v2.x * v1.y, v2.x * v0.y - v0.x * v2.y, v0.x * v1.y - v1.x * v0.y);\n"
"    B *= (1 / det);\n"
"    return (B);\n"
"}\n"
"fn select_hull_vertex(p0 : vec2f, p1 : vec2f, p2 : vec2f, p3 : vec2f) -> vec2f\n"
"{\n"
"    /*NOTE: check intersection of lines (p1-p0) and (p3-p2)\n"
"		P = p0 + u(p1-p0)\n"
"		P = p2 + w(p3-p2)\n"
"		control points are inside a right triangle so we should always find an intersection\n"
"	*/\n"
"    var pm : vec2f;\n"
"    let det : f32 = (p1.x - p0.x) * (p3.y - p2.y) - (p1.y - p0.y) * (p3.x - p2.x);\n"
"    let sqrNorm0 : f32 = dot(p1 - p0, p1 - p0);\n"
"    let sqrNorm1 : f32 = dot(p2 - p3, p2 - p3);\n"
"    if(abs(det) < 1e-3 || sqrNorm0 < 0.1 || sqrNorm1 < 0.1)\n"
"    {\n"
"        if(sqrNorm0 < sqrNorm1)\n"
"        {\n"
"            pm = p2;\n"
"        }\n"
"        else\n"
"        {\n"
"            pm = p1;\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"        let u : f32 = ((p0.x - p2.x) * (p2.y - p3.y) - (p0.y - p2.y) * (p2.x - p3.x)) / det;\n"
"        pm = p0 + u * (p1 - p0);\n"
"    }\n"
"    return (pm);\n"
"}\n"
"fn cubic_emit(curve : cubic_info, p : array<vec2f, 4>, s0 : f32, s1 : f32, sp : array<vec2f, 4>, pathIndex : i32, debugID : i32)\n"
"{\n"
"    let segIndex : u32  = push_segment(sp, OC_SEG_CUBIC, pathIndex);\n"
"    if(segIndex < arrayLength(&segmentBuffer))\n"
"    {\n"
"        var v0 : vec2f = p[0];\n"
"        var v1 : vec2f = p[3];\n"
"        var v2 : vec2f;\n"
"        var K : mat3x3f;\n"
"        //TODO: haul that up in caller, we don't need to compute K for all monotonic segments\n"
"        let sqrNorm0 : f32 = dot(p[1] - p[0], p[1] - p[0]);\n"
"        let sqrNorm1 : f32 = dot(p[2] - p[3], p[2] - p[3]);\n"
"        if(dot(p[0] - p[3], p[0] - p[3]) > 1e-5)\n"
"        {\n"
"            if(sqrNorm0 >= sqrNorm1)\n"
"            {\n"
"                v2 = p[1];\n"
"                K = mat3x3f(curve.K[0].xyz, curve.K[3].xyz, curve.K[1].xyz);\n"
"            }\n"
"            else\n"
"            {\n"
"                v2 = p[2];\n"
"                K = mat3x3f(curve.K[0].xyz, curve.K[3].xyz, curve.K[2].xyz);\n"
"            }\n"
"        }\n"
"        else\n"
"        {\n"
"            v1 = p[1];\n"
"            v2 = p[2];\n"
"            K = mat3x3f(curve.K[0].xyz, curve.K[1].xyz, curve.K[2].xyz);\n"
"        }\n"
"        //NOTE: set matrices\n"
"        //TODO: should we compute matrix relative to a base point to avoid loss of precision\n"
"        //      when computing barycentric matrix?\n"
"        let B : mat3x3f = barycentric_matrix(v0, v1, v2);\n"
"        segmentBuffer[segIndex].implicitMatrix = K * B;\n"
"        segmentBuffer[segIndex].hullVertex = select_hull_vertex(sp[0], sp[1], sp[2], sp[3]);\n"
"        //NOTE: compute sign flip\n"
"        segmentBuffer[segIndex].sign = 1;\n"
"        if(curve.kind == CUBIC_SERPENTINE\n"
"           || curve.kind == CUBIC_CUSP)\n"
"        {\n"
"            if(curve.d1 < 0)\n"
"            {\n"
"                segmentBuffer[segIndex].sign =  -1;\n"
"            }\n"
"            else\n"
"            {\n"
"                segmentBuffer[segIndex].sign = 1;\n"
"            }\n"
"        }\n"
"        else if(curve.kind == CUBIC_LOOP)\n"
"        {\n"
"            let d1 : f32 = curve.d1;\n"
"            let d2 : f32 = curve.d2;\n"
"            let d3 : f32 = curve.d3;\n"
"            let H0 : f32 = d3 * d1 - squaref(d2) + d1 * d2 * s0 - squaref(d1) * squaref(s0);\n"
"            let H1 : f32 = d3 * d1 - squaref(d2) + d1 * d2 * s1 - squaref(d1) * squaref(s1);\n"
"            var H : f32;\n"
"            if(abs(H0) > abs(H1))\n"
"            {\n"
"                H = H0;\n"
"            }\n"
"            else\n"
"            {\n"
"                H = H1;\n"
"            }\n"
"            if(H * d1 > 0)\n"
"            {\n"
"                segmentBuffer[segIndex].sign = -1;\n"
"            }\n"
"            else\n"
"            {\n"
"                 segmentBuffer[segIndex].sign = 1;\n"
"            }\n"
"        }\n"
"        if(sp[3].y > sp[0].y)\n"
"        {\n"
"            segmentBuffer[segIndex].sign *= -1;\n"
"        }\n"
"        segmentBuffer[segIndex].debugID = debugID;\n"
"        bin_to_tiles(segIndex);\n"
"    }\n"
"}\n"
"fn cubic_setup(p : array<vec2f, 4>, pathIndex : i32)\n"
"{\n"
"    /*NOTE(martin): first convert the control points to power basis, multiplying by M3\n"
"		     | 1  0  0  0|      |p0|      |c0|\n"
"		M3 = |-3  3  0  0|, B = |p1|, C = |c1| = M3*B\n"
"		     | 3 -6  3  0|      |p2|      |c2|\n"
"		     |-1  3 -3  1|      |p3|      |c3|\n"
"	*/\n"
"    let c = array<vec2f, 4>(\n"
"        p[0],\n"
"        3.0 * (p[1] - p[0]),\n"
"        3.0 * (p[0] + p[2] - 2 * p[1]),\n"
"        3.0 * (p[1] - p[2]) + p[3] - p[0]\n"
"    );\n"
"    //NOTE: get classification, implicit matrix, double points and inflection points\n"
"    let curve : cubic_info = cubic_classify(c);\n"
"    if(curve.kind == CUBIC_DEGENERATE_LINE)\n"
"    {\n"
"        let l = array<vec2f, 4>(p[0], p[3], vec2f(0, 0), vec2f(0, 0));\n"
"        line_setup(l, pathIndex);\n"
"        return;\n"
"    }\n"
"    else if(curve.kind == CUBIC_DEGENERATE_QUADRATIC)\n"
"    {\n"
"        let quadPoint = vec2f(1.5 * p[1].x - 0.5 * p[0].x, 1.5 * p[1].y - 0.5 * p[0].y);\n"
"        let q = array<vec2f, 4>(p[0], quadPoint, p[3], vec2(0));\n"
"        quadratic_setup(q, pathIndex);\n"
"        return;\n"
"    }\n"
"    //NOTE: get the roots of B'(s) = 3.c3.s^2 + 2.c2.s + c1\n"
"    var rootsX : array<f32, 2>;\n"
"    let rootCountX : i32 = quadratic_roots(3 * c[3].x, 2 * c[2].x, c[1].x, &rootsX);\n"
"    var rootsY : array<f32, 2>;\n"
"    let rootCountY : i32 = quadratic_roots(3 * c[3].y, 2 * c[2].y, c[1].y, &rootsY);\n"
"    var roots : array<f32, 6>;\n"
"    for(var i : i32 = 0; i < rootCountX; i++)\n"
"    {\n"
"        roots[i] = rootsX[i];\n"
"    }\n"
"    for(var i : i32 = 0; i < rootCountY; i++)\n"
"    {\n"
"        roots[i + rootCountX] = rootsY[i];\n"
"    }\n"
"    //NOTE: add double points and inflection points to roots if finite\n"
"    var rootCount : i32 = rootCountX + rootCountY;\n"
"    for(var i : i32 = 0; i < 2; i++)\n"
"    {\n"
"        if(curve.ts[i].y != 0)\n"
"        {\n"
"            roots[rootCount] = curve.ts[i].x / curve.ts[i].y;\n"
"            rootCount++;\n"
"        }\n"
"    }\n"
"    //NOTE: sort roots\n"
"    for(var i : i32 = 1; i < rootCount; i++)\n"
"    {\n"
"        let tmp : f32 = roots[i];\n"
"        var j : i32 = i - 1;\n"
"        while(j >= 0 && roots[j] > tmp)\n"
"        {\n"
"            roots[j + 1] = roots[j];\n"
"            j--;\n"
"        }\n"
"        roots[j + 1] = tmp;\n"
"    }\n"
"    //NOTE: compute split points\n"
"    var splits : array<f32, 8>;\n"
"    var splitCount : i32 = 0;\n"
"    splits[0] = 0;\n"
"    splitCount++;\n"
"    for(var i : i32 = 0; i < rootCount; i++)\n"
"    {\n"
"        if(roots[i] > 0 && roots[i] < 1)\n"
"        {\n"
"            splits[splitCount] = roots[i];\n"
"            splitCount++;\n"
"        }\n"
"    }\n"
"    splits[splitCount] = 1;\n"
"    splitCount++;\n"
"    //NOTE: for each monotonic segment, compute hull matrix and sign, and emit segment\n"
"    for(var sliceIndex : i32 = 0; sliceIndex < splitCount - 1; sliceIndex++)\n"
"    {\n"
"        let s0 : f32 = splits[sliceIndex];\n"
"        let s1 : f32 = splits[sliceIndex + 1];\n"
"        var sp : array<vec2f, 4>;\n"
"        cubic_slice(p, s0, s1, &sp);\n"
"        cubic_emit(curve, p, s0, s1, sp, pathIndex, sliceIndex);\n"
"    }\n"
"}\n"
"//--------------------------------------------------------------\n"
"//NOTE: entry point, dispatch to setup procs\n"
"//--------------------------------------------------------------\n"
"@compute @workgroup_size(16, 16) fn segment_setup(@builtin(workgroup_id) workGroupID : vec3u,\n"
"                                                @builtin(local_invocation_id) localID : vec3u)\n"
"{\n"
"    let eltIndex : u32 = workGroupID.x * (16*16) + localID.y * 16 + localID.x;\n"
"    if(eltIndex >= eltCount)\n"
"    {\n"
"        return;\n"
"    }\n"
"    let elt = &eltBuffer[eltIndex];\n"
"    let p = array<vec2f, 4>(\n"
"        (*elt).p[0],\n"
"        (*elt).p[1],\n"
"        (*elt).p[2],\n"
"        (*elt).p[3]);\n"
"    switch((*elt).kind)\n"
"    {\n"
"        case OC_SEG_LINE, default:\n"
"        {\n"
"            line_setup(p, (*elt).pathIndex);\n"
"        }\n"
"        case OC_SEG_QUADRATIC:\n"
"        {\n"
"            quadratic_setup(p, (*elt).pathIndex);\n"
"        }\n"
"        case OC_SEG_CUBIC:\n"
"        {\n"
"            cubic_setup(p, (*elt).pathIndex);\n"
"        }\n"
"    }\n"
"}\n";

//NOTE: string imported from src/graphics/wgsl_shaders/backprop.wgsl
const char* oc_wgsl_backprop = 
"//------------------------------------------------------------------------------------------------\n"
"// Backprop pass\n"
"//------------------------------------------------------------------------------------------------\n"
"@group(0) @binding(0) var<storage, read> pathBins : array<oc_path_bin>;\n"
"@group(0) @binding(1) var<uniform> pathCount : u32;\n"
"@group(0) @binding(2) var<storage, read_write> binQueues : array<oc_bin_queue>;\n"
"var<workgroup> nextRowIndex : atomic<i32>;\n"
"@compute @workgroup_size(16) fn backprop(@builtin(num_workgroups) workGroupCount : vec3u,\n"
"                                         @builtin(workgroup_id) workGroupID : vec3u)\n"
"{\n"
"    atomicStore(&nextRowIndex, 0);\n"
"    workgroupBarrier();\n"
"    let pathIndex : u32 = workGroupID.y * workGroupCount.x + workGroupID.x;\n"
"    if(pathIndex >= pathCount)\n"
"    {\n"
"        return;\n"
"    }\n"
"    let pathBin = &pathBins[pathIndex];\n"
"    let rowSize : i32 = (*pathBin).area.z;\n"
"    let rowCount : i32 = (*pathBin).area.w;\n"
"    let binQueueStartIndex = (*pathBin).binQueues;\n"
"    var rowIndex : i32 = atomicAdd(&nextRowIndex, 1);\n"
"    while(rowIndex < rowCount)\n"
"    {\n"
"        var sum : i32 = 0;\n"
"        for(var x : i32 = rowSize - 1; x >= 0; x--)\n"
"        {\n"
"            let tileIndex : i32 = binQueueStartIndex + rowIndex * rowSize + x;\n"
"            let offset : i32 = binQueues[tileIndex].windingOffset;\n"
"            binQueues[tileIndex].windingOffset = sum;\n"
"            sum += offset;\n"
"        }\n"
"        rowIndex = atomicAdd(&nextRowIndex, 1);\n"
"    }\n"
"}\n";

//NOTE: string imported from src/graphics/wgsl_shaders/chunk.wgsl
const char* oc_wgsl_chunk = 
"//------------------------------------------------------------------------------------------------\n"
"// Chunk pass\n"
"//------------------------------------------------------------------------------------------------\n"
"@group(0) @binding(0) var<storage, read> paths : array<oc_path>;\n"
"@group(0) @binding(1) var<uniform> pathCount : u32;\n"
"@group(0) @binding(2) var<storage, read_write> chunks : array<oc_chunk>;\n"
"@group(0) @binding(3) var<storage, read_write> chunkElements : array<oc_chunk_elt>;\n"
"@group(0) @binding(4) var<storage, read_write> chunkEltCount : atomic<u32>;\n"
"@group(0) @binding(5) var<uniform> chunkSize : u32;\n"
"@compute @workgroup_size(1) fn chunk(@builtin(num_workgroups) workGroupCount : vec3u,\n"
"                                     @builtin(workgroup_id) workGroupID : vec3u)\n"
"{\n"
"    let chunkBoxMin = vec2f(workGroupID.xy * chunkSize);\n"
"    let chunkBoxMax = chunkBoxMin + vec2f(f32(chunkSize), f32(chunkSize));\n"
"    let chunkIndex = workGroupID.y * workGroupCount.x + workGroupID.x;\n"
"    let chunk = &chunks[chunkIndex];\n"
"    (*chunk).first = -1;\n"
"    (*chunk).last = -1; // could be local only\n"
"    for(var pathIndex : u32 = 0; pathIndex < pathCount ; pathIndex++)\n"
"    {\n"
"        let pathBox : vec4f = paths[pathIndex].box;\n"
"        if(  pathBox.x < chunkBoxMax.x\n"
"          && pathBox.y < chunkBoxMax.y\n"
"          && pathBox.z >= chunkBoxMin.x\n"
"          && pathBox.w >= chunkBoxMin.y)\n"
"        {\n"
"            var eltIndex : u32 = atomicAdd(&chunkEltCount, 1u);\n"
"            let elt = &chunkElements[eltIndex];\n"
"            (*elt).pathIndex = pathIndex;\n"
"            if((*chunk).first < 0)\n"
"            {\n"
"                (*chunk).last = i32(eltIndex);\n"
"            }\n"
"            (*elt).next = (*chunk).first;\n"
"            (*chunk).first = i32(eltIndex);\n"
"        }\n"
"    }\n"
"}\n";

//NOTE: string imported from src/graphics/wgsl_shaders/merge.wgsl
const char* oc_wgsl_merge = 
"//------------------------------------------------------------------------------------------------\n"
"// Merge pass\n"
"//------------------------------------------------------------------------------------------------\n"
"@group(0) @binding(0) var<storage, read> pathBuffer : array<oc_path>;\n"
"@group(0) @binding(1) var<uniform> pathCount : u32;\n"
"@group(0) @binding(2) var<storage, read> chunks : array<oc_chunk>;\n"
"@group(0) @binding(3) var<storage, read> chunkElements : array<oc_chunk_elt>;\n"
"@group(0) @binding(4) var<storage, read> pathBins : array<oc_path_bin>;\n"
"@group(0) @binding(5) var<storage, read> binQueues : array<oc_bin_queue>;\n"
"@group(0) @binding(6) var<storage, read> binQueueCount : u32;\n"
"@group(0) @binding(7) var<storage, read_write> tileOpBuffer : array<oc_tile_op>;\n"
"@group(0) @binding(8) var<storage, read_write> tileOpCount : atomic<u32>;\n"
"@group(0) @binding(9) var<storage, read_write> tileQueues : array<oc_tile_queue>;\n"
"@group(0) @binding(10) var<storage, read_write> tileCount : atomic<u32>;\n"
"@group(0) @binding(11) var<uniform> tileSize : u32;\n"
"@group(0) @binding(12) var<uniform> chunkSize : u32;\n"
"@compute @workgroup_size(1) fn merge(@builtin(num_workgroups) workGroupCount : vec3u,\n"
"                                     @builtin(global_invocation_id) gid : vec3u)\n"
"{\n"
"    let tilesPerChunk : u32 = chunkSize / u32(tileSize);\n"
"    let tileCoord : vec2u = gid.xy;\n"
"    let chunkCoord : vec2u = tileCoord / tilesPerChunk;\n"
"    let chunkCount : vec2u = (workGroupCount.xy + vec2u(tilesPerChunk - 1, tilesPerChunk - 1)) / tilesPerChunk;\n"
"    let chunkIndex : u32 = chunkCoord.y * chunkCount.x + chunkCoord.x;\n"
"    var tileIndex : i32 = -1;\n"
"    var lastOpIndex : i32 = -1;\n"
"    for(var chunkEltIndex = chunks[chunkIndex].first;\n"
"        chunkEltIndex >= 0;\n"
"        chunkEltIndex = chunkElements[chunkEltIndex].next)\n"
"    {\n"
"        let pathIndex = chunkElements[chunkEltIndex].pathIndex;\n"
"        let pathBin = pathBins[pathIndex];\n"
"        let binCoord : vec2i = vec2i(tileCoord) - pathBin.area.xy;\n"
"        let pathBox : vec4f = pathBuffer[pathIndex].box;\n"
"        let clip : vec4f = pathBuffer[pathIndex].clip;\n"
"        let xMax = min(pathBox.z, clip.z);\n"
"        let tileMax : i32 = i32(xMax) / i32(tileSize);\n"
"        let pathTileMax : i32 = tileMax - pathBin.area.x;\n"
"        if(binCoord.x >= 0\n"
"           && binCoord.x <= pathTileMax\n"
"           && binCoord.y >= 0\n"
"           && binCoord.y < pathBin.area.w)\n"
"        {\n"
"            if(tileIndex < 0)\n"
"            {\n"
"                tileIndex = i32(atomicAdd(&tileCount, 1u));\n"
"                tileQueues[tileIndex].tileCoord = tileCoord;\n"
"                tileQueues[tileIndex].first = -1;\n"
"            }\n"
"            let binQueueIndex : i32 = pathBin.binQueues + binCoord.y * pathBin.area.z + binCoord.x;\n"
"            let binQueue = &binQueues[binQueueIndex];\n"
"            let windingOffset : i32 = (*binQueue).windingOffset;\n"
"            let firstOpIndex : i32 = (*binQueue).first;\n"
"            var tileBox = vec4f(f32(tileCoord.x), f32(tileCoord.y), f32(tileCoord.x + 1), f32(tileCoord.y + 1));\n"
"            tileBox *= f32(tileSize);\n"
"            if(tileBox.x >= clip.z\n"
"               || tileBox.z < clip.x\n"
"               || tileBox.y >= clip.w\n"
"               || tileBox.w < clip.y)\n"
"            {\n"
"                //NOTE: tile is fully outside clip, cull it\n"
"                //TODO: move that test up\n"
"            }\n"
"            else if(firstOpIndex == -1)\n"
"            {\n"
"                //NOTE: This bin queue has no ops. This means the tile is fully inside or fully outside the path\n"
"                if( ((pathBuffer[pathIndex].cmd == OC_CMD_FILL) && ((windingOffset & 1) != 0))\n"
"                  ||((pathBuffer[pathIndex].cmd == OC_CMD_STROKE) && (windingOffset != 0)))\n"
"                {\n"
"                    //NOTE: tile is full covered. Add fill op (with winding offset).\n"
"                    //      Additionally if color is opaque and tile is fully inside clip, trim tile list.\n"
"                    let opIndex = atomicAdd(&tileOpCount, 1u);\n"
"                    if(opIndex >= arrayLength(&tileOpBuffer))\n"
"                    {\n"
"                        //TODO: signal there's not enough tile ops\n"
"                        return;\n"
"                    }\n"
"                    tileOpBuffer[opIndex].kind = OC_OP_CLIP_FILL;\n"
"                    tileOpBuffer[opIndex].next = -1;\n"
"                    tileOpBuffer[opIndex].index = pathIndex;\n"
"                    tileOpBuffer[opIndex].windingOffsetOrCrossRight = windingOffset;\n"
"                    if(lastOpIndex < 0)\n"
"                    {\n"
"                        tileQueues[tileIndex].first = i32(opIndex);\n"
"                    }\n"
"                    else\n"
"                    {\n"
"                        tileOpBuffer[lastOpIndex].next = i32(opIndex);\n"
"                    }\n"
"                    if(tileBox.x >= clip.x\n"
"                       && tileBox.z < clip.z\n"
"                       && tileBox.y >= clip.y\n"
"                       && tileBox.w < clip.w)\n"
"                    {\n"
"                        tileOpBuffer[opIndex].kind = OC_OP_FILL;\n"
"                        if(pathBuffer[pathIndex].colors[0].a == 1\n"
"                           && pathBuffer[pathIndex].textureID < 0)\n"
"                        {\n"
"                            //NOTE(martin): the tile is fully opaque, so no need to continue\n"
"                            // traversing lower-Z paths\n"
"                            return;\n"
"                        }\n"
"                    }\n"
"                    lastOpIndex = i32(opIndex);\n"
"                }\n"
"                // else, tile is fully uncovered, skip path\n"
"            }\n"
"            else\n"
"            {\n"
"                //NOTE: add path start op (with winding offset)\n"
"                let startOpIndex : u32 = atomicAdd(&tileOpCount, 1u);\n"
"                if(startOpIndex >= arrayLength(&tileOpBuffer))\n"
"                {\n"
"                    //TODO signal there's not enough tile ops\n"
"                    return;\n"
"                }\n"
"                tileOpBuffer[startOpIndex].kind = OC_OP_START;\n"
"                tileOpBuffer[startOpIndex].next = -1;\n"
"                tileOpBuffer[startOpIndex].index = pathIndex;\n"
"                tileOpBuffer[startOpIndex].windingOffsetOrCrossRight = windingOffset;\n"
"                if(lastOpIndex < 0)\n"
"                {\n"
"                    tileQueues[tileIndex].first = i32(startOpIndex);\n"
"                }\n"
"                else\n"
"                {\n"
"                    tileOpBuffer[lastOpIndex].next = i32(startOpIndex);\n"
"                }\n"
"                lastOpIndex = i32(startOpIndex);\n"
"                //NOTE: chain remaining path ops to end of tile list\n"
"                tileOpBuffer[lastOpIndex].next = firstOpIndex;\n"
"                lastOpIndex = (*binQueue).last;\n"
"                //NOTE: add path end op\n"
"                let endOpIndex : u32 = atomicAdd(&tileOpCount, 1u);\n"
"                if(endOpIndex >= arrayLength(&tileOpBuffer))\n"
"                {\n"
"                    //TODO signal there's not enough tile ops\n"
"                    return;\n"
"                }\n"
"                tileOpBuffer[endOpIndex].kind = OC_OP_END;\n"
"                tileOpBuffer[endOpIndex].next = -1;\n"
"                tileOpBuffer[endOpIndex].index = pathIndex;\n"
"                //tileOpBuffer[endOpIndex].windingOffsetOrCrossRight = windingOffset;\n"
"                if(lastOpIndex < 0)\n"
"                {\n"
"                    tileQueues[tileIndex].first = i32(endOpIndex);\n"
"                }\n"
"                else\n"
"                {\n"
"                    tileOpBuffer[lastOpIndex].next = i32(endOpIndex);\n"
"                }\n"
"                lastOpIndex = i32(endOpIndex);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n";

//NOTE: string imported from src/graphics/wgsl_shaders/balance_workgroups.wgsl
const char* oc_wgsl_balance_workgroups = 
"//------------------------------------------------------------------------------------------------\n"
"// Balance workgroups\n"
"//------------------------------------------------------------------------------------------------\n"
"@group(0) @binding(0) var<storage, read_write> dispatchWorkGroups : array<u32, 3>;\n"
"@group(0) @binding(1) var<uniform> maxWorkGroupsPerDimension : u32;\n"
"@compute @workgroup_size(1) fn balance_workgroups()\n"
"{\n"
"    let totalWorkGroupCount : u32 = dispatchWorkGroups[0];\n"
"    if(totalWorkGroupCount > maxWorkGroupsPerDimension)\n"
"    {\n"
"        dispatchWorkGroups[0] = maxWorkGroupsPerDimension;\n"
"    }\n"
"    else\n"
"    {\n"
"        dispatchWorkGroups[0] = totalWorkGroupCount;\n"
"    }\n"
"    dispatchWorkGroups[1] = (totalWorkGroupCount + maxWorkGroupsPerDimension - 1) / maxWorkGroupsPerDimension;\n"
"    dispatchWorkGroups[2] = 1;\n"
"}\n";

//NOTE: string imported from src/graphics/wgsl_shaders/raster.wgsl
const char* oc_wgsl_raster = 
"//------------------------------------------------------------------------------------------------\n"
"// Raster\n"
"//------------------------------------------------------------------------------------------------\n"
"const OC_WGPU_MAX_SAMPLE_COUNT : u32 = 8;\n"
"const OC_WGPU_SOURCE_SAMPLE_COUNT : u32 = 2;\n"
"@group(0) @binding(0) var<storage, read> pathBuffer : array<oc_path>;\n"
"@group(0) @binding(1) var<storage, read> segmentBuffer : array<oc_segment>;\n"
"@group(0) @binding(2) var<storage, read> tileQueues : array<oc_tile_queue>;\n"
"@group(0) @binding(3) var<storage, read> tileOpBuffer : array<oc_tile_op>;\n"
"@group(0) @binding(4) var<storage, read> msaaOffsets : array<vec2f, OC_WGPU_MAX_SAMPLE_COUNT>;\n"
"@group(0) @binding(5) var<uniform> msaaSampleCount : u32;\n"
"@group(0) @binding(6) var<uniform> tileSize : u32;\n"
"@group(0) @binding(7) var outTexture : texture_storage_2d<rgba8unorm, write>;\n"
"@group(0) @binding(8) var<uniform> debugDisplayOptions : oc_debug_display_options;\n"
"// source textures bindgroup\n"
"@group(1) @binding(0) var srcTexture0 : texture_2d<f32>;\n"
"@group(1) @binding(1) var srcTexture1 : texture_2d<f32>;\n"
"@group(1) @binding(2) var srcTexture2 : texture_2d<f32>;\n"
"@group(1) @binding(3) var srcTexture3 : texture_2d<f32>;\n"
"@group(1) @binding(4) var srcTexture4 : texture_2d<f32>;\n"
"@group(1) @binding(5) var srcTexture5 : texture_2d<f32>;\n"
"@group(1) @binding(6) var srcTexture6 : texture_2d<f32>;\n"
"@group(1) @binding(7) var srcTexture7 : texture_2d<f32>;\n"
"//NOTE: you can't sample from textures in a compute shaders (wtf?), so... we do it ourselves\n"
"fn sampleFromTexture(texture : texture_2d<f32>, uv : vec2f) -> vec4f\n"
"{\n"
"    var color : vec4f;\n"
"    if(uv.x < 0 || uv.y < 0 || uv.x > 1 || uv.y > 1)\n"
"    {\n"
"        color = vec4f(0, 0, 0, 0);\n"
"    }\n"
"    else\n"
"    {\n"
"        let p : vec2f = clamp(uv * vec2f(textureDimensions(texture)) - vec2f(0.5, 0.5),\n"
"                              vec2f(0, 0),\n"
"                              vec2f(textureDimensions(texture)) - vec2f(1, 1));\n"
"        let r = fract(p);\n"
"        let tl = vec2i(p);\n"
"        let bl = tl + vec2i(0, 1);\n"
"        let tr = tl + vec2i(1, 0);\n"
"        let br = tl + vec2i(1, 1);\n"
"        let tlColor : vec4f = textureLoad(texture, tl, 0);\n"
"        let blColor : vec4f = textureLoad(texture, bl, 0);\n"
"        let trColor : vec4f = textureLoad(texture, tr, 0);\n"
"        let brColor : vec4f = textureLoad(texture, br, 0);\n"
"        let lColor : vec4f = (1-r.y) * tlColor + r.y * blColor;\n"
"        let rColor : vec4f = (1-r.y) * trColor + r.y * brColor;\n"
"        color = (1-r.x) * lColor + r.x * rColor;\n"
"    }\n"
"    return(color);\n"
"}\n"
"const DEBUG_COLOR_QUEUE_EMPTY = vec4f(1, 0, 1, 1);\n"
"const DEBUG_COLOR_QUEUE_NOT_EMPTY = vec4f(0, 1, 0, 1);\n"
"const DEBUG_COLOR_FILL_OP = vec4f(1, 0, 0, 1);\n"
"fn get_next_color(pathIndex : u32, sampleCoord : vec2f) -> vec4f\n"
"{\n"
"    var nextColor : vec4f;\n"
"    if(pathBuffer[pathIndex].hasGradient == 0)\n"
"    {\n"
"        nextColor = pathBuffer[pathIndex].colors[0];\n"
"    }\n"
"    else\n"
"    {\n"
"        var sampleColor = vec4f(0, 0, 0, 0);\n"
"        var bl = pathBuffer[pathIndex].colors[0];\n"
"        var br = pathBuffer[pathIndex].colors[1];\n"
"        var tr = pathBuffer[pathIndex].colors[2];\n"
"        var tl = pathBuffer[pathIndex].colors[3];\n"
"        if(pathBuffer[pathIndex].blendSpace == 1)\n"
"        {\n"
"            bl = pow(bl, vec4f(0.454545, 0.454545, 0.454545, 1));\n"
"            br = pow(br, vec4f(0.454545, 0.454545, 0.454545, 1));\n"
"            tr = pow(tr, vec4f(0.454545, 0.454545, 0.454545, 1));\n"
"            tl = pow(tl, vec4f(0.454545, 0.454545, 0.454545, 1));\n"
"        }\n"
"        let sampleCoord3 = vec3f(sampleCoord, 1);\n"
"        let uv : vec2f = (pathBuffer[pathIndex].uvTransform * sampleCoord3).xy;\n"
"        let bottomColor : vec4f = (1. - uv.x) * bl + uv.x * br;\n"
"        let topColor : vec4f = (1. - uv.x) * tl + uv.x * tr;\n"
"        sampleColor += uv.y * bottomColor + (1 - uv.y) * topColor;\n"
"        nextColor = sampleColor;\n"
"        if(pathBuffer[pathIndex].blendSpace == 1)\n"
"        {\n"
"            nextColor = pow(nextColor, vec4f(2.2, 2.2, 2.2, 1));\n"
"        }\n"
"    }\n"
"    nextColor = vec4f(nextColor.rgb * nextColor.a, nextColor.a);\n"
"    let textureID : i32 = pathBuffer[pathIndex].textureID;\n"
"    if(  textureID >= 0\n"
"      && debugDisplayOptions.textureOff == 0)\n"
"    {\n"
"        var texColor = vec4f(0, 0, 0, 0);\n"
"        let sampleCoord3 = vec3f(sampleCoord, 1);\n"
"        let uv : vec2f = (pathBuffer[pathIndex].uvTransform * sampleCoord3).xy;\n"
"        if(textureID == 0)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture0, uv);\n"
"        }\n"
"        else if(textureID == 1)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture1, uv);\n"
"        }\n"
"        else if(textureID == 2)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture2, uv);\n"
"        }\n"
"        else if(textureID == 3)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture3, uv);\n"
"        }\n"
"        else if(textureID == 4)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture4, uv);\n"
"        }\n"
"        else if(textureID == 5)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture5, uv);\n"
"        }\n"
"        else if(textureID == 6)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture6, uv);\n"
"        }\n"
"        else if(textureID == 7)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture7, uv);\n"
"        }\n"
"        texColor = vec4f(texColor.rgb*texColor.a, texColor.a);\n"
"        nextColor *= texColor;\n"
"    }\n"
"    return(nextColor);\n"
"}\n"
"/*\n"
"fn get_next_color(pathIndex : u32, sampleCoord : vec2f) -> vec4f\n"
"{\n"
"    var nextColor : vec4f;\n"
"    if(pathBuffer[pathIndex].hasGradient == 0)\n"
"    {\n"
"        nextColor = pathBuffer[pathIndex].colors[0];\n"
"    }\n"
"    else\n"
"    {\n"
"        var sampleColor = vec4f(0, 0, 0, 0);\n"
"        var bl = pathBuffer[pathIndex].colors[0];\n"
"        var br = pathBuffer[pathIndex].colors[1];\n"
"        var tr = pathBuffer[pathIndex].colors[2];\n"
"        var tl = pathBuffer[pathIndex].colors[3];\n"
"        if(pathBuffer[pathIndex].blendSpace == 1)\n"
"        {\n"
"            bl = pow(bl, vec4f(0.454545, 0.454545, 0.454545, 1));\n"
"            br = pow(br, vec4f(0.454545, 0.454545, 0.454545, 1));\n"
"            tr = pow(tr, vec4f(0.454545, 0.454545, 0.454545, 1));\n"
"            tl = pow(tl, vec4f(0.454545, 0.454545, 0.454545, 1));\n"
"        }\n"
"        let sampleCoord3 = vec3f(sampleCoord, 1);\n"
"        let uv : vec2f = (pathBuffer[pathIndex].uvTransform * sampleCoord3).xy;\n"
"        let bottomColor : vec4f = (1. - uv.x) * bl + uv.x * br;\n"
"        let topColor : vec4f = (1. - uv.x) * tl + uv.x * tr;\n"
"        sampleColor += uv.y * bottomColor + (1 - uv.y) * topColor;\n"
"        nextColor = sampleColor;\n"
"        if(pathBuffer[pathIndex].blendSpace == 1)\n"
"        {\n"
"            nextColor = pow(nextColor, vec4f(2.2, 2.2, 2.2, 1));\n"
"        }\n"
"    }\n"
"    nextColor = vec4f(nextColor.rgb * nextColor.a, nextColor.a);\n"
"    let textureID : i32 = pathBuffer[pathIndex].textureID;\n"
"    if(  textureID >= 0\n"
"      && debugDisplayOptions.textureOff == 0)\n"
"    {\n"
"        var texColor = vec4f(0, 0, 0, 0);\n"
"        let sampleCoord3 = vec3f(sampleCoord, 1);\n"
"        let uv : vec2f = (pathBuffer[pathIndex].uvTransform * sampleCoord3).xy;\n"
"        if(textureID == 0)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture0, uv);\n"
"        }\n"
"        else if(textureID == 1)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture1, uv);\n"
"        }\n"
"        else if(textureID == 2)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture2, uv);\n"
"        }\n"
"        else if(textureID == 3)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture3, uv);\n"
"        }\n"
"        else if(textureID == 4)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture4, uv);\n"
"        }\n"
"        else if(textureID == 5)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture5, uv);\n"
"        }\n"
"        else if(textureID == 6)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture6, uv);\n"
"        }\n"
"        else if(textureID == 7)\n"
"        {\n"
"            texColor += sampleFromTexture(srcTexture7, uv);\n"
"        }\n"
"        texColor = vec4f(texColor.rgb*texColor.a, texColor.a);\n"
"        nextColor *= texColor;\n"
"    }\n"
"    return(nextColor);\n"
"}\n"
"*/\n"
"@compute @workgroup_size(16, 16) fn raster(@builtin(num_workgroups) workGroupCount : vec3u,\n"
"                                           @builtin(workgroup_id) workGroupID : vec3u,\n"
"                                           @builtin(local_invocation_id) localID : vec3u)\n"
"{\n"
"    let tileQueueIndex : u32 = workGroupID.y * workGroupCount.x + workGroupID.x;\n"
"    let tileQueue = &tileQueues[tileQueueIndex];\n"
"    let pixCoord = vec2i((*tileQueue).tileCoord * tileSize + localID.xy);\n"
"    let centerCoord = vec2f(pixCoord) + vec2f(0.5, 0.5);\n"
"    var sampleCoords : array<vec2f, OC_WGPU_MAX_SAMPLE_COUNT>;\n"
"    for(var sampleIndex : u32 = 0; sampleIndex < msaaSampleCount; sampleIndex++)\n"
"    {\n"
"        sampleCoords[sampleIndex] = centerCoord + msaaOffsets[sampleIndex];\n"
"    }\n"
"    var color = vec4f(0, 0, 0, 0);\n"
"    /*\n"
"    if(debugDisplayOptions.showPathArea != 0)\n"
"    {\n"
"        color = vec4f(0, 0, 0, 0.1);\n"
"    }\n"
"    */\n"
"    var opIndex : i32 = (*tileQueue).first;\n"
"    var winding = array<i32, OC_WGPU_MAX_SAMPLE_COUNT>(\n"
"        0, 0, 0, 0, 0, 0, 0, 0\n"
"    );\n"
"    /*\n"
"    if(debugDisplayOptions.debugTileQueues != 0)\n"
"    {\n"
"        if(opIndex >= 0)\n"
"        {\n"
"            color = DEBUG_COLOR_QUEUE_NOT_EMPTY;\n"
"        }\n"
"        else\n"
"        {\n"
"            color = DEBUG_COLOR_QUEUE_EMPTY;\n"
"        }\n"
"    }\n"
"    */\n"
"    while(opIndex >= 0)\n"
"    {\n"
"        var op : oc_tile_op = tileOpBuffer[opIndex];\n"
"        if(op.kind == OC_OP_START)\n"
"        {\n"
"            for(var sampleIndex : u32 = 0; sampleIndex < msaaSampleCount; sampleIndex++)\n"
"            {\n"
"                winding[sampleIndex] = op.windingOffsetOrCrossRight;\n"
"            }\n"
"        }\n"
"        else if(op.kind == OC_OP_SEGMENT)\n"
"        {\n"
"            var seg : oc_segment = segmentBuffer[op.index];\n"
"            for(var sampleIndex : u32 = 0; sampleIndex < msaaSampleCount; sampleIndex++)\n"
"            {\n"
"                let samplePos : vec2f = sampleCoords[sampleIndex];\n"
"                if((samplePos.y > seg.box.y)\n"
"                   && (samplePos.y <= seg.box.w)\n"
"                   && (side_of_segment(samplePos.xy, seg) < 0))\n"
"                {\n"
"                    winding[sampleIndex] += seg.windingIncrement;\n"
"                }\n"
"                if(op.windingOffsetOrCrossRight != 0)\n"
"                {\n"
"                    if((seg.config == OC_SEG_BR || seg.config == OC_SEG_TL)\n"
"                       && (samplePos.y > seg.box.w))\n"
"                    {\n"
"                        winding[sampleIndex] += seg.windingIncrement;\n"
"                    }\n"
"                    else if((seg.config == OC_SEG_BL || seg.config == OC_SEG_TR)\n"
"                            && (samplePos.y > seg.box.y))\n"
"                    {\n"
"                        winding[sampleIndex] -= seg.windingIncrement;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        else\n"
"        {\n"
"            let pathIndex : u32 = op.index;\n"
"            let nextColor : vec4f = get_next_color(pathIndex, centerCoord);\n"
"            if(op.kind == OC_OP_FILL)\n"
"            {\n"
"                color = nextColor * (1 - color.a) + color;\n"
"                // if(debugDisplayOptions.debugTileQueues != 0)\n"
"                // {\n"
"                //     color = DEBUG_COLOR_FILL_OP;\n"
"                // }\n"
"            }\n"
"            else\n"
"            {\n"
"                let clip : vec4f = pathBuffer[pathIndex].clip;\n"
"                var coverage : f32 = 0;\n"
"                for(var sampleIndex : u32 = 0; sampleIndex < msaaSampleCount; sampleIndex++)\n"
"                {\n"
"                    let sampleCoord : vec2f = sampleCoords[sampleIndex];\n"
"                    //TODO: do that test when computing winding number?\n"
"                    if(sampleCoord.x >= clip.x\n"
"                      && sampleCoord.x < clip.z\n"
"                      && sampleCoord.y >= clip.y\n"
"                      && sampleCoord.y < clip.w)\n"
"                    {\n"
"                        var filled : bool = (op.kind == OC_OP_CLIP_FILL)\n"
"                                          || (pathBuffer[pathIndex].cmd == OC_CMD_FILL\n"
"                                              && ((winding[sampleIndex] & 1) != 0))\n"
"                                          || (pathBuffer[pathIndex].cmd == OC_CMD_STROKE\n"
"                                              && (winding[sampleIndex] != 0));\n"
"                        if(filled)\n"
"                        {\n"
"                            coverage += 1;\n"
"                        }\n"
"                    }\n"
"                }\n"
"                if(coverage != 0)\n"
"                {\n"
"                    coverage /= f32(msaaSampleCount);\n"
"                    color = coverage*nextColor * (1 - color.a) + color;\n"
"                    if(coverage == 1 && nextColor.a == 1)\n"
"                    {\n"
"                        break;\n"
"                    }\n"
"                }\n"
"                // if(debugDisplayOptions.showClip != 0)\n"
"                // {\n"
"                //     var coverage : f32 = 0;\n"
"                //     for(var sampleIndex : u32 = 0; sampleIndex < msaaSampleCount; sampleIndex++)\n"
"                //     {\n"
"                //         let sampleCoord : vec2f = sampleCoords[sampleIndex];\n"
"                //         if(  sampleCoord.x > clip.x - 0.5\n"
"                //           && sampleCoord.x < clip.z + 0.5\n"
"                //           && sampleCoord.y > clip.y - 0.5\n"
"                //           && sampleCoord.y < clip.w + 0.5)\n"
"                //         {\n"
"                //             if(  sampleCoord.x < clip.x + 0.5\n"
"                //               || sampleCoord.x > clip.z - 0.5\n"
"                //               || sampleCoord.y < clip.y + 0.5\n"
"                //               || sampleCoord.y > clip.w - 0.5)\n"
"                //             {\n"
"                //                 coverage +=1;\n"
"                //             }\n"
"                //         }\n"
"                //     }\n"
"                //     coverage /= f32(msaaSampleCount);\n"
"                //     color = coverage * vec4f(1,0,1,1) + (1 - coverage) * color;\n"
"                // }\n"
"            }\n"
"        }\n"
"        opIndex = op.next;\n"
"    }\n"
"    // if(  debugDisplayOptions.showTileBorders != 0\n"
"    //   && (pixCoord.x % i32(tileSize) == 0 || pixCoord.y % i32(tileSize) == 0))\n"
"    // {\n"
"    //     color = 0.5 * color + vec4f(0, 0, 0, 0.5);\n"
"    // }\n"
"    textureStore(outTexture, pixCoord, color);\n"
"}\n";

//NOTE: string imported from src/graphics/wgsl_shaders/blit.wgsl
const char* oc_wgsl_blit = 
"//------------------------------------------------------------------------------------------------\n"
"// Blit\n"
"//------------------------------------------------------------------------------------------------\n"
"@group(0) @binding(0) var outTexture : texture_2d<f32>;\n"
"/*\n"
"struct vertex_out\n"
"{\n"
"    @builtin(position) pos : vec4f,\n"
"    @location(0) uv : vec2f,\n"
"};\n"
"*/\n"
"@vertex fn vs(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4f\n"
"{\n"
"    var pos = vec2f(f32((vertexIndex << 1) & 2), f32(vertexIndex & 2));\n"
"    var out : vec4f = vec4f(0, 0, 0, 1);\n"
"    out = vec4f(pos * vec2f(2, 2) + vec2f(-1, -1), 0.0, 1.0);\n"
"    return out;\n"
"}\n"
"@fragment fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f\n"
"{\n"
"    var color = textureLoad(outTexture, vec2u(pos.xy), 0);\n"
"    return (color);\n"
"}\n";

//NOTE: string imported from src/graphics/wgsl_shaders/final_blit.wgsl
const char* oc_wgsl_final_blit = 
"//------------------------------------------------------------------------------------------------\n"
"// Blit\n"
"//------------------------------------------------------------------------------------------------\n"
"@group(0) @binding(0) var outTexture : texture_2d<f32>;\n"
"/*\n"
"struct vertex_out\n"
"{\n"
"    @builtin(position) pos : vec4f,\n"
"    @location(0) uv : vec2f,\n"
"};\n"
"*/\n"
"@vertex fn vs(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4f\n"
"{\n"
"    var pos = vec2f(f32((vertexIndex << 1) & 2), f32(vertexIndex & 2));\n"
"    var out : vec4f = vec4f(0, 0, 0, 1);\n"
"    out = vec4f(pos * vec2f(2, 2) + vec2f(-1, -1), 0.0, 1.0);\n"
"    return out;\n"
"}\n"
"@fragment fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f\n"
"{\n"
"    var color = textureLoad(outTexture, vec2u(pos.xy), 0);\n"
"    let gamma : f32 = 1./2.4;\n"
"    let rgb = select(1.055 * pow(color.rgb, vec3f(gamma, gamma, gamma)) - vec3f(0.055, 0.055, 0.055),\n"
"                     color.rgb*12.92,\n"
"                     color.rgb <= vec3f(0.0031308, 0.0031308, 0.0031308));\n"
"    color = vec4f(rgb, color.a);\n"
"    return (color);\n"
"}\n";

#endif // __WGPU_RENDERER_SHADERS_H__
