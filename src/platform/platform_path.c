/*************************************************************************
*
*  Orca
*  Copyright 2023 Martin Fouilleul and the Orca project contributors
*  See LICENSE.txt for licensing information
*
**************************************************************************/

#include "platform_path.h"

oc_str8 oc_path_slice_directory(oc_str8 fullPath)
{
    i64 lastSlashIndex = -1;

    i64 i = fullPath.len - 1;
    if(i > 0 && fullPath.ptr[i] == '/')
    {
        //NOTE: Ignore trailing slash
        i--;
    }
    for(; i >= 0; i--)
    {
        if(fullPath.ptr[i] == '/')
        {
            lastSlashIndex = i;
            break;
        }
    }

    oc_str8 directory = { 0 };
    if(lastSlashIndex < 0)
    {
        directory = OC_STR8(".");
    }
    else if(lastSlashIndex == 0)
    {
        directory = OC_STR8("/");
    }
    else
    {
        directory = oc_str8_slice(fullPath, 0, lastSlashIndex);
    }

    return (directory);
}

oc_str8 oc_path_slice_filename(oc_str8 fullPath)
{
    i64 lastSlashIndex = -1;

    i64 end = fullPath.len;
    i64 i = end - 1;
    if(i > 0 && fullPath.ptr[i] == '/')
    {
        //NOTE: Ignore trailing slash
        end--;
        i--;
    }
    for(; i >= 0; i--)
    {
        if(fullPath.ptr[i] == '/')
        {
            lastSlashIndex = i;
            break;
        }
    }

    oc_str8 basename = oc_str8_slice(fullPath, lastSlashIndex + 1, end);
    return (basename);
}

oc_str8_list oc_path_split(oc_arena* arena, oc_str8 path)
{
    oc_arena_scope tmp = oc_scratch_begin_next(arena);
    oc_str8 sep = OC_STR8("/");
    oc_str8_list split = { 0 };
    oc_str8_list_push(tmp.arena, &split, sep);

    oc_str8_list res = oc_str8_split(arena, path, split);

    //TODO(pld): do strip first '/' on Windows?
    //NOTE: strip empty elements (which could be generated by consecutive '/')
    oc_list_for_safe(res.list, elt, oc_str8_elt, listElt)
    {
        if(elt->string.len == 0)
        {
            oc_str8_list_remove(&res, elt);
        }
    }

    if(oc_str8_eq(oc_str8_slice(path, 0, 1), sep))
    {
      oc_str8_list_push_front(tmp.arena, &res, oc_str8_push_copy(tmp.arena, sep));
    }

    oc_scratch_end(tmp);
    return (res);
}

oc_str8 oc_path_join(oc_arena* arena, oc_str8_list elements)
{
    //TODO: check if elements should end with '/'?

    oc_str8 prefix = OC_STR8("");
    oc_str8 sep = OC_STR8("/");
    oc_str8_elt* first = oc_list_first_entry(elements.list, oc_str8_elt, listElt);
    if(oc_str8_eq(first->string, sep))
    {
      prefix = sep;
      //TODO(pld): rework to not modify list
      oc_str8_list_remove(&elements, first);
    }
    oc_str8 res = oc_str8_list_collate(arena, elements, prefix, sep, (oc_str8){ 0 });
    return (res);
}

oc_str8 oc_path_append(oc_arena* arena, oc_str8 parent, oc_str8 relPath)
{
    oc_str8 result = { 0 };

    if(parent.len == 0)
    {
        result = oc_str8_push_copy(arena, relPath);
    }
    else if(relPath.len == 0)
    {
        result = oc_str8_push_copy(arena, parent);
    }
    else
    {
        oc_arena_scope tmp = oc_scratch_begin_next(arena);

        oc_str8_list list = { 0 };
        oc_str8_list_push(tmp.arena, &list, parent);
        if((parent.ptr[parent.len - 1] != '/') && (relPath.ptr[0] != '/'))
        {
            oc_str8_list_push(tmp.arena, &list, OC_STR8("/"));
        }
        oc_str8_list_push(tmp.arena, &list, relPath);

        result = oc_str8_list_join(arena, list);

        oc_scratch_end(tmp);
    }
    return (result);
}

#if !OC_PLATFORM_ORCA

oc_str8 oc_path_executable_relative(oc_arena* arena, oc_str8 relPath)
{
    oc_str8_list list = { 0 };
    oc_arena_scope scratch = oc_scratch_begin_next(arena);

    oc_str8 executablePath = oc_path_executable(scratch.arena);
    oc_str8 dirPath = oc_path_slice_directory(executablePath);

    oc_str8 path = oc_path_append(arena, dirPath, relPath);

    oc_scratch_end(scratch);
    return (path);
}

#endif
