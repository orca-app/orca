/*************************************************************************
*
*  Orca
*  Copyright 2023 Martin Fouilleul and the Orca project contributors
*  See LICENSE.txt for licensing information
*
**************************************************************************/

#include "platform_path.h"

oc_str8 oc_path_slice_directory(oc_str8 fullPath)
{
    i64 lastSlashIndex = -1;

    for(i64 i = fullPath.len - 1; i >= 0; i--)
    {
        if(fullPath.ptr[i] == '/')
        {
            lastSlashIndex = i;
            break;
        }
    }

    oc_str8 directory = { 0 };
    if(lastSlashIndex < 0)
    {
        directory = OC_STR8(".");
    }
    else if(lastSlashIndex == 0)
    {
        directory = OC_STR8("/");
    }
    else
    {
        directory = oc_str8_slice(fullPath, 0, lastSlashIndex);
    }

    return (directory);
}

oc_str8 oc_path_slice_filename(oc_str8 fullPath)
{
    i64 lastSlashIndex = -1;

    for(i64 i = fullPath.len - 1; i >= 0; i--)
    {
        if(fullPath.ptr[i] == '/')
        {
            lastSlashIndex = i;
            break;
        }
    }

    oc_str8 basename = oc_str8_slice(fullPath, lastSlashIndex + 1, fullPath.len);
    return (basename);
}

oc_str8 oc_path_slice_stem(oc_str8 path)
{
    oc_str8 basename = oc_path_slice_filename(path);
    //NOTE: ignore leading dots
    u64 i = 0;
    for(; i < basename.len; i++)
    {
        if(basename.ptr[i] != '.')
        {
            break;
        }
    }
    //NOTE: now search to the first dot
    for(; i < basename.len; i++)
    {
        if(basename.ptr[i] == '.')
        {
            return oc_str8_slice(basename, 0, i);
        }
    }
    return (oc_str8){ 0 };
}

oc_str8 oc_path_slice_extension(oc_str8 path)
{
    oc_str8 basename = oc_path_slice_filename(path);
    for(u64 i = basename.len; i > 0; i--)
    {
        if(basename.ptr[i] == '.')
        {
            return oc_str8_slice(basename, i, basename.len);
        }
    }
    return (oc_str8){ 0 };
}

oc_str8_list oc_path_split(oc_arena* arena, oc_str8 path)
{
    oc_arena_scope tmp = oc_scratch_begin_next(arena);
    oc_str8_list sep = { 0 };
    oc_str8_list_push(tmp.arena, &sep, OC_STR8("/"));

    oc_str8_list res = oc_str8_split(arena, path, sep);

    if(path.len && path.ptr[0] == '/')
    {
        //NOTE: if path is absolute, add the leading slash as the first element
        oc_str8_list_push_front(arena, &res, OC_STR8("/"));
    }

    //NOTE: strip empty elements (which could be generated by consecutive '/')
    oc_list_for_safe(res.list, elt, oc_str8_elt, listElt)
    {
        if(elt->string.len == 0)
        {
            oc_list_remove(&res.list, &elt->listElt);
        }
    }

    oc_scratch_end(tmp);
    return (res);
}

oc_str8 oc_path_join(oc_arena* arena, oc_str8_list elements)
{
    //TODO: check if elements have ending/begining '/' ?
    oc_arena_scope scratch = oc_scratch_begin_next(arena);
    oc_str8_list list = { 0 };
    oc_str8_list_for(elements, elt)
    {
        //NOTE: skip empty elements
        if(elt->string.len)
        {
            u64 start = 0;
            u64 end = elt->string.len;

            //NOTE: eliminate leading slashes
            while(start < elt->string.len && elt->string.ptr[start] == '/')
            {
                start++;
            }
            //NOTE: for first element, keep at most 1 leading slash
            if(&elt->listElt == elements.list.first && start != 0)
            {
                start--;
            }

            //NOTE: eliminate trailing slashes
            while(end > start && elt->string.ptr[end - 1] == '/')
            {
                end--;
            }
            //NOTE: for last element, keep at most 1 trailing slash
            if(&elt->listElt == elements.list.last && end != elt->string.len)
            {
                end++;
            }
            oc_str8_list_push(scratch.arena, &list, oc_str8_slice(elt->string, start, end));
        }
    }
    oc_str8 res = oc_str8_list_collate(arena, list, OC_STR8(""), OC_STR8("/"), OC_STR8(""));

    oc_scratch_end(scratch);
    return (res);
}

oc_str8 oc_path_append(oc_arena* arena, oc_str8 parent, oc_str8 relPath)
{
    oc_str8 result = { 0 };

    if(parent.len == 0)
    {
        result = oc_str8_push_copy(arena, relPath);
    }
    else if(relPath.len == 0)
    {
        result = oc_str8_push_copy(arena, parent);
    }
    else
    {
        oc_arena_scope tmp = oc_scratch_begin_next(arena);

        oc_str8_list list = { 0 };
        oc_str8_list_push(tmp.arena, &list, parent);
        if((parent.ptr[parent.len - 1] != '/') && (relPath.ptr[0] != '/'))
        {
            oc_str8_list_push(tmp.arena, &list, OC_STR8("/"));
        }
        oc_str8_list_push(tmp.arena, &list, relPath);

        result = oc_str8_list_join(arena, list);

        oc_scratch_end(tmp);
    }
    return (result);
}

#if !defined(OC_PLATFORM_ORCA) || !OC_PLATFORM_ORCA

oc_str8 oc_path_executable_relative(oc_arena* arena, oc_str8 relPath)
{
    oc_str8_list list = { 0 };
    oc_arena_scope scratch = oc_scratch_begin_next(arena);

    oc_str8 executablePath = oc_path_executable(scratch.arena);
    oc_str8 dirPath = oc_path_slice_directory(executablePath);

    oc_str8 path = oc_path_append(scratch.arena, dirPath, relPath);
    path = oc_path_canonical(arena, path);

    oc_scratch_end(scratch);
    return (path);
}

#endif
