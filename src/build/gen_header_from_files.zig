// This is a zig program run as part of the orca build process to generate a header file
// embedding strings of passed-along text files.

const std = @import("std");

const Options = struct {
    arena: std.mem.Allocator,
    out_path: []const u8,
    in_paths: []const []const u8,
    namespace: []const u8,
    root: []const u8,

    fn parse(args: []const [:0]const u8, arena: std.mem.Allocator) !Options {
        var out_path: ?[]const u8 = null;
        var in_paths = std.ArrayList([]const u8).init(arena);
        var namespace: ?[]const u8 = null;
        var root: ?[]const u8 = null;

        for (args, 0..) |raw_arg, i| {
            if (i == 0) {
                continue;
            }

            var split_iter = std.mem.splitScalar(u8, raw_arg, '=');
            const arg: []const u8 = split_iter.next().?;
            if (std.mem.eql(u8, arg, "--output")) {
                out_path = split_iter.next();
            } else if (std.mem.eql(u8, arg, "--file")) {
                if (split_iter.next()) |path| {
                    try in_paths.append(path);
                }
            } else if (std.mem.eql(u8, arg, "--namespace")) {
                namespace = split_iter.next();
            } else if (std.mem.eql(u8, arg, "--root")) {
                root = split_iter.next();
            }
        }

        var missing_arg: ?[]const u8 = null;
        if (out_path == null) {
            missing_arg = "output";
        } else if (in_paths.items.len == 0) {
            missing_arg = "file";
        } else if (namespace == null) {
            missing_arg = "namespace";
        } else if (root == null) {
            missing_arg = "root";
        }

        if (missing_arg) |arg| {
            std.log.err("Missing required arg: {s}", .{arg});
            return error.MissingRequiredArgument;
        }

        return Options{
            .arena = arena,
            .out_path = out_path.?,
            .in_paths = in_paths.items,
            .namespace = namespace.?,
            .root = root.?,
        };
    }
};

fn basenameNoExtension(path: []const u8) []const u8 {
    const filename: []const u8 = std.fs.path.basename(path);
    if (std.mem.lastIndexOf(u8, filename, ".")) |index| {
        return filename[0..index];
    }
    return filename;
}

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator: std.mem.Allocator = arena.allocator();

    const args: []const [:0]u8 = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    const opts = try Options.parse(args, allocator);

    var concat = std.ArrayList(u8).init(allocator);
    defer concat.deinit();

    const filename: []const u8 = std.fs.path.basename(opts.out_path);
    const filename_no_ext: []const u8 = basenameNoExtension(filename);
    const guard_name: []u8 = try allocator.dupe(u8, filename_no_ext);
    for (guard_name) |*c| {
        c.* = std.ascii.toUpper(c.*);
    }

    var writer = concat.writer();

    try writer.print("/*********************************************************************\n", .{});
    try writer.print("*\n", .{});
    try writer.print("*\tfile: {s}\n", .{filename});
    try writer.print("*\tnote: string literals auto-generated by gen_header_from_files.zig\n", .{});
    try writer.print("*\n", .{});
    try writer.print("**********************************************************************/\n", .{});

    try writer.print("#ifndef __{s}_H__\n", .{guard_name});
    try writer.print("#define __{s}_H__\n", .{guard_name});
    try writer.print("\n\n", .{});

    const cwd = std.fs.cwd();
    for (opts.in_paths) |input_path| {
        const file_contents = try cwd.readFileAlloc(allocator, input_path, 1024 * 1024 * 128);
        defer allocator.free(file_contents);

        const input_path_filename: []const u8 = std.fs.path.basename(input_path);
        const input_path_relative: []u8 = try allocator.dupe(u8, input_path[opts.root.len + 1 ..]); // +1 to remove the trailing /

        std.mem.replaceScalar(u8, input_path_relative, '\\', '/');
        const input_path_no_ext: []const u8 = basenameNoExtension(input_path_filename);

        try writer.print("//NOTE: string imported from {s}\n", .{input_path_relative});
        try writer.print("const char* {s}{s} = \n", .{ opts.namespace, input_path_no_ext });

        var split_iter = std.mem.tokenizeAny(u8, file_contents, "\r\n");
        while (split_iter.next()) |line| {
            const line_fmt =
                \\"{s}\n"
            ;
            try writer.print(line_fmt, .{line});
            if (split_iter.peek() != null) {
                try writer.print("\n", .{});
            }
        }

        try writer.print(";\n\n", .{});
    }

    try writer.print("#endif // __{s}_H__\n", .{guard_name});

    try cwd.writeFile(.{
        .sub_path = opts.out_path,
        .data = concat.items,
        .flags = .{ .truncate = true },
    });
}
